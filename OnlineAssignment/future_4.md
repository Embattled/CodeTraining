## Reverse Calculate

* 最初の時、全部N個のトランプの位置を計算するのアルゴリズムを実装した、時間制限を超えた、ですから正方向計算は無理で。
* 逆考えなら、ある疑問Tに対して、直接最後の位置を計算すれば、時間制限は大丈夫と思う。（Qがより小さいだから）
* その計算方法は：
  * Nはシャッフルの数、Tは目的な数字、Tの最初の位置i = T
  * aimは次のシャッフル移動する目的のIndex、aim = すでに完成したシャッフルの数
  * 最初の T-1　回目のシャッフルは、Tの位置に影響がない、だからスキップする
    * `N = T-1`
    * `aim = T-1`
    * `i = T`
  * それ後で、もし`i!=1`、つまり次回シャッフルされたトランプはTではない時、`i--`、それで：
    * `while(n>=i)` もしTがシャッフルされたチャンスはまだある時
      * `n-=i` `aim+=i` その時にジャンプする（この時 i=1）
      * `i = aim` シャッフルする
    * `while`が終わった後、もし`n>0`、つまり　T　はまだ移動する必要がある
      * `i-=n`　残ったシャッフル数 `n` はTの位置を `n`番前に移動する


```cpp
ll t;
cin>>t;

// N = rest shuffle time
// i = now index
// aim = shuffle aim place
ll n=N-(t-1),i=t,aim=t-1;

while(n>=i){
    n-=i;
    aim+=i;
    i=aim;
}
if(n>0){
    i-=n;
}
cout<<i<<endl;
```

