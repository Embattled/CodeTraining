# E

* O(n) 方法直接平推
* 记录好:
  * flag: 是否满足出现了 minX, maxY 的情况, 其他值都在范围内
  * Index_start: 第一次出现 范围内的值
  * 对于向后查找, 如果 i 值满足范围内, 切 flag 为真:
    * ans += min(IndexMin, IndexMax) - Index_start
  * 如果出现了范围外的值:
    * flag = false 两个都报废
    * Index_start= i  重新开始记录起始 index

# F

先运用并查集方法, 将问题化简成一个个圆, 对每个圆来说, 怎么选择边使得每个点都被 cover 到, 圆之间的组合数相乘即可
* 并查集要写的比较细心

基础问题: 对于一条直线上的 x 个点, 以及连接左右的共 x+1 条边, 求边的选择方法使得 每个点都有一条边相连 g(x)
* g(0)=2    :没有点, 一条边, 边存在无所谓
* g(1)=3    : 都留, or 去除左右
* g(2)=5    : 都留, or 去除左中右 or 去除左右 
* g(x)=g(x-1)+g(x-2):
  * 假设最左边的边一定选, 则最左边的点已满足条件, 相当于子问题 g(x-1)
  * 假设最左边的边一定不选, 则左边第2号的边一定得选, 相当于子问题 g(x-2)

对于一个有 x 个边的圆, 即 x 个点, f(x)
* f(1) = 1
* f(2) = 3
* f(3) = 4
* f(x) = g(x-2)+g(x-4)
  * 确定选择一条边,  剩下 x-1 条边相当于问题 g(x-2)
  * 确定不选择一条边, 相邻的两条边则必须选, 相当于 3 条边被固定, 相当于问题 g(x-4)