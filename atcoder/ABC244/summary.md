# G

审题:
* 顶点个数超多 10^5
* 边维持在了 10^5 以内
* 只是说构建一个 Good Path, 没有要求最短
* 给出的图也是简单图, 无复边无环


方法:
* 深度优先算法, 递归函数
* 建立图的一个任意深度搜索树 (使用 check 数组), 阻止死循环
* 对于任意一个点, 搜索每个孩子
  * 如果子树里, 孩子的个数与 s 要求的奇偶性不符
  * 则添加一个 父-子 小路径
  * 搜索完成叶子后, 再添加以一个 自身 节点, 代表搜索完所有子树后, 路径点仍然在自身
* 对于最终的初始点(特殊处理):
  * 如果初始点 v0 与 s0 的要求不符
  * 添加一个 第一子-0-第一子 的小路径

证明 (使用一个星图, n个点的n-1条边都链接在 0 号顶点):
* 正常无 s 约束的搜索, 产生的路径长 2n-1, 0号点出现 n 次, 剩余 n-1个点都是奇数次出现
* 假设 s 约束为全部偶数, 所有子路径都是  0-x-0-x, 共 4(n-1)+1 长度, 以0 结尾, 此时0 号节点必为奇数, 再添加一个 x-0-x 即可更改 0 的出现次数为偶
* 此时路径的极限长度为 4n, 满足题的条件

# F

审题:
* 要求最短
* 顶点数相当少 (n<=17)
* 讨论所有情况  2^n <= 131072, 在 O(n) 的范围内


方法:
* 核心关键是, 在每一个可能情况 (s) 下, 都有n个子情况 (以第 x 号顶点结束 path)
* 广度优先搜索, 从每个单独顶点开始
  * 此时即为  s=0...010...0 (只有1个1) 的最佳情况
  * 由此情况生成的下一个搜索状况自动都是最佳路径
  * 创建 `dp[1<<n][n]` 的统计表, 每个表项只用计算一次, 不需要进行最小化判断 
* 在统计结果的时候, 只加 `dp[s][1-n]` 的 n 项中的最小值
* 复杂度约为 `2*(1<<n)+m`

# E

题解:
* 标准的 2维DP 问题的小改进
* 在第三位加入了一个 是否 分支
* 初始值为 `dp[初始点][0][0]`
* 计算完整个 dp 表最终返回对应的 `dp[终点顶点][路径长度][x出现偶数情况]`

