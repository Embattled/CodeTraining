# F 16进制

* 16进制数字的搜索, 要求出现的数字种类个数为 k, 求不大于s的数字的个数
* s的长度极长, 字符串格式读入

* 只需要求数字种类数为 k 的数字个数, 并不在乎具体是由哪几种数字构成, 依据此条件降低计算复杂度
  * `dp[n][17]` n 代表搜索范围, 即字符串的长度, 17 代表数字种类的个数的 dp
  * 这里的dp 仅仅只是为了防止重复搜索, 因此前后不关联, 赋初值 -1
  * 因为是深度优先搜索, `dp[n][k]` 代表从左向右的第n个位置,(len(s)-n)位数能够导致数字种类个数为k的数有多少个
  * 
* 区分两类特殊情况
  * 头部数字全为0, 则头部全为0的部分不能作为 0 数字种类计算进去
  * 头部数字部分和 s相同, 即不能对大于s的数字进行搜索, 因此需要限制搜索路径
  * 特殊情况不能作为dp记录
* 区分普通情况
  * 头部数字已经有非0的数, 则新出现的0可以作为种类计入 `x |= (1<<0)`
  * 头部数字有比s小的部分, 则后面的部分可以任意取值, 一定比s小, 属于合法搜索

**深度优先搜索**
* 用两个bool变量来保存两类特殊情况, 特殊情况是部分搜索且不计入 dp
* 初始传入的特殊情况变量都为 false, 因为前面没有数字, 即代表两种特殊情况都要考虑
* 初始传入的 number set 为 0

# E MexMin

* 给定数列上的 Mex操作
* 给定查找区间 k, 查找区间移动, 求Mex函数结果的最小值, 但是不在乎是哪一个区间得到的
* 确保单次遍历即可


# D 计算概率

* 每次平等概率选择一个点并建立链接
* 求图变成连通图的期望跳跃次数
* 考虑逐渐能够跳跃到新点的概率  (n-1)/n  ->  1/n
* 每次加上概率的倒数即可
* 浮点数结果需要设置取消科学计数法, 并且最好加上精度设置
  * `cout<<fixed<<setprecision(10)<<res<<endl;`
