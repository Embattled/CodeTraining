## F

给定 N 个数, 进行 N-1 次操作, 求最后剩下的值有几种可能  
`2<N<2000`    

操作: 选择 gcd(x,y) 或者 min(x,y) 替换 x和y   

思考点:
1. 不管 gcd 还是 min, 得到的值 k一定满足 `k<=x and k<=y`
2. 不管怎么进行 min(x,y) 得到的值也一定是原本 `a[i]` 或者 `gcd` 得来的值, 不会有新值
   对所有 gcd 进行判定即可包括所有 min 的情况
3. 对所有 `a[i]` 的所有因子进行两两判定, 满足条件的代表可以纳入结果
   * 该因子必须小于 `min(A)`  因为 `思考点 1`
   * 用 map 来记录, key 代表A中数的因子, value 代表 `A[i]` 之间能否通过 gcd 得到该因子

## E

* 图搜索问题
* 使用不记录的 dfs 也能在时间限制内完成

高速算法只用了 `141 ms`, 用了带边权的 BFS, 使用 priority_queue 

## D

二分查找即可 O(nlongn)  找到每个x 周的上下边界