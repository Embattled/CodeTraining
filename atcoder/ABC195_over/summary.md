## F

* 注意 B-A <= 72 的条件, 允许对每一个数字进行遍历
* 思考数对互质的条件, `GCD(n,m)=GCD(n−m,m)≤n−m≤B−A`
  * 因为两数之差最大为 72, 因此只需考虑 2~72 的质数因子
  * `2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71`
* 一个符合要求的 set , 每个质数因子只出现一次
  * bit mask 搜索
* 求出每个数的质数因子的 bit mask
  * 和 `1<<20` 的 bit mask 进行与操作, 如果为0, 代表可以合并
  * 则 bit mask 的或操作为旧 bit mask 的 dp 数

## E

* 最优化情况下的博弈问题 (较为简化)
* 双方都在预知未来的情况下进行最优化, 每次只能由一个人操作
  * 倒叙搜索
  * 对于上一个剩下的数和这一次加入的数进行分析
  * 如果这个 mod 剩下的数能够在未来导致胜利

  

